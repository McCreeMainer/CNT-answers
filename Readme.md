# 1. Архитектуры компьютерных сетей, их характеристики.

Архитектура - спецификации связи, разработанные для определения функций сети и установления стандартов различных моделей вычислительных систем, предназначенных для обмена и обработки данных.

Для стандартизации сетей Международная организация стандартов (ISO/OSI) предложила семиуровневую сетевую архитектуру. Это предложение хорошо в теории, но конкретные реализации сетей не используют все уровни международного стандарта. Однако этот стандарт дает общее представление о взаимодействии отдельных подсистем сети и потому выступает «эталоном».

## Семиуровневая сетевая архитектура

1. **Физический уровень (Physical Layer).** Обеспечивает виртуальную линию связи для передачи данных между узлами сети. На этом уровне выполняется преобразование данных, поступающих от следующего, более высокого уровня, в сигналы, передающиеся по физическим носителям. Элемент информации – бит. Примеры протоколов, действующих на этом уровне - Wi-Fi, Bluetooth.

2. **Канальный (Data Link Layer).** Обеспечивает виртуальную линию связи более высокого уровня, способную безошибочно передавать данные в асинхронном режиме. При этом данные обычно передаются блоками, содержащими дополнительную управляющую информацию. Такие блоки называют кадрами. При возникновении ошибок автоматически выполняется повторная посылка кадра. Кроме того, на уровне управления линией передачи данных обычно обеспечивается правильная последовательность передаваемых и принимаемых кадров. Последнее означает, что если один компьютер передает другому несколько блоков данных, то принимающий компьютер получит эти блоки данных именно в той последовательности, в какой они были переданы. Пример протокола, действующего на этом уровне - Token ring.

3. **Сетевой уровень (Network Layer).** Предполагает, что с каждым узлом сети связан некий процесс. Процессы, работающие на узлах сети, взаимодействуют друг с другом и обеспечивают выбор маршрута передачи данных в сети (маршрутизацию), а также управление потоком данных в сети. В частности, на этом уровне должна выполняться буферизация данных. Элемент информации – дейтаграмма (пакет). Пример протокола, действующего на этом уровне - IPv4, IPv6, ICMP.

4. **Транспортный уровень (Transport Layer).** Выполняет разделение передаваемых сообщений на пакеты на передающем конце и сборку на приемном конце. На этом уровне может выполняться согласование сетевых уровней различных несовместимых между собой сетей через специальные шлюзы. Например, такое согласование потребуется для объединения локальных сетей в глобальные. Элемент информации – пакет (сегмент, дейтаграмма). Пример протоколов, действующих на этом уровне – UDP, TCP, SCTP.

5. **Сеансовый уровень (Session Layer).** Обеспечивает поддержание/разрыв сеанса связи, позволяя приложениям взаимодействовать между собой длительное время. Уровень управляет созданием/завершением сеанса, обменом информацией, синхронизацией задач, определением права на передачу данных и поддержанием сеанса в периоды неактивности приложений. На практике этот уровень зачастую «отпадает». Элемент информации – сообщение. Пример протокола, действующего на этом уровне – SOCKS.

6. **Уровень представления (Presentation Layer).** Описывает шифрование данных, их сжатие и кодовое преобразование. На практике этот уровень зачастую «отпадает». Элемент информации – сообщение. Например, к этому уровню можно отнести шифрование ASCII.

7. **Прикладной уровень (Application Layer).** Отвечает за поддержку прикладного программного обеспечения конечного пользователя. Элемент информации – сообщение. Пример протоколов, действующих на этом уровне – TELNET, POP3, SMTP, HTTP.

Уровни с межсетевого по прикладной реализуются програмно.

## Архитектуры КС

- ODNA (DECNet) - Основным коммутационным элементом сетевой архитектуры DNA является узел. Все узлы равноправны, т.е. каждый узел, может выступать в качестве любого функционального элемента ИВС. Узлы закреплены за различными областями (подобластями). Каждая область имеет своего администратора и средства маршрутизации. Каждый узел имеет свой уникальный адрес. Структура адреса DECnet-4: 1 байт -номер области, 1 байт - номер подобласти, 6 байт - Ethernet адрес.
- SNA
- DARPA (TCP/IP, Internet)
- Novell Netware
- SMB
- AppleTalk
- XNS
- IPv6

**Характеристики:**

1. Иерархия протоколов

2. Соответствие модели ISO

3. Адресация
   - Узлов
     - Индивидуальная
     - Групповая
     - Широковещательная
   - Приложений

4. Связь сетевого и канального уровней
   - Разрешение адресов
   - Фрагментация
     - Поузловая // IPv4
     - На источнике // IPv6

5. Сетевые протоколы

6. Маршрутизация
   - По типу маршрута
     - Индивидуальная
     - Групповая
   - По адаптивности к изменениям в сети
     - Статическая
     - Динамическая
     - Предопределенная («от источника»)
   - По месту проведения маршрутных вычислений
     - Централизованная
     - Децентрализованная // Характерно для TCP/IP
     - Гибридная
   - По числу возможных маршрутов
     - Однопутевые
     - Многопутевые
   - По характеру используемой информации
     - Глобальные
     - Локальные // Большинство
     - Смешанные

7. Транспортные механизмы
   - Дейтаграммные транспортные протоколы
   - Потоковые транспортные протоколы
   - Многопоточные транспортные протоколы

8. Именование ресурсов
   - Одноуровневое
   - Двухуровневое
   - Иерархическое

9. Прикладные протоколы
   - Протоколы удаленного терминала
   - Протоколы передачи файлов
   - Протоколы электронной почты
   - …

10. Управление

11. Защита информации

# 2. Архитектура TCP/IP. Иерархия протоколов.

![hierarchy](img/hierarchy.png)

7. Физический

6. Канальный

5. Сетевой

4. Транспортный

3. Сеансовый

2. Представления

1. Прикладной 

**ARP Address Resolution Protocol** - Отвечает за получение MAC адреса хоста, размещенного в текущей сети, по его IP адресу. Использует broadcast. Для передачи данных по сети хост должен знать MAC адрес хоста, которому передаются данные. Для получения МАС адреса по известному IP адресу служит протокол ARP.

**ICMP Internet Control Message Protocol** - Посылка сообщений об ошибках, обнаруженных в процессе передачи пакетов. Служит для общения маршрутизатора с хостом, отправляющим или посылающим данные контрольными сообщениями и сообщениями об ошибках. Использует для передачи IP и является его составной частью.

**IGMP Internet Group Management Protocol** - Информирует маршрутизаторы о наличии в данной сети multicast группы. Информация рассылается по маршрутизаторам, поддерживающим рассылку таких сообщений.

**IP Internet Protocol** - Обеспечивает маршрутизацию пакетов. IP не устанавливает непосредственное соединение между хостами, а используют адреса, помещенные в заголовок IP пакета, для передачи их получателям. Выбор пути передачи называется маршрутизацией. IP используют поля в заголовке для фрагментации и восстановления датаграмм Internet, когда это необходимо для их передачи через сети с малым размером пакетов. Не требует подтверждения получения данных. Это означает, что отправитель и получатель не информируются о пропаже пакета или неправильной последовательности получения пакетов.

**TCP Transmission Control Protocol** - Обеспечивает соединение между двумя хостами, с гарантируемой доставкой пакетов. Транспортный протокол с гарантированной доставкой пакетов. Данные представляются как поток байтов и могут передаваться в обоих направлениях. Некоторое количество октетов могут упаковываться в сегменты для передачи через системы Internet. Достоверность передачи информации достигается присваиванием каждому сегменту уникального номера в последовательности. Для проверки доставки сегмента используются подтверждения (ACK), которые возвращаются для каждого посланного сегмента. Если подтверждение не получено, то данные посылаюся еще раз через некоторый интервал времени (timeout). Если сегмент пришел поврежденным, то хост уничтожает этот пакет и не посылает подтверждение получения.

**UDP User Datagram Protocol** - Обеспечивает соединение между двумя хостами, при котором не гарантируется доставка пакетов. Обеспечивает соединение с негарантированной доставкой пакетов. Используется в приложениях, не требующих подтверждения получения пакетов (NetBIOS name service, NetBIOS datagram service, SNMP).

# 5. Архитектура сетей ТСP/IP. Протокол IP.

**IP – Internet Protocol** – межсетевой протокол. Нужен, чтобы объединить разные сети, использующие разные технологии передачи данных. IP – основной протокол, использующийся в Интернете.

В модели ISO/OSI расположен на Сетевом уровне

![IP в OSI](img/IP_OSI.png)

В модели TCP/IP расположен на Сетевом уровне

![IP в TCP IP](img/IP_TCP.png)

IP передает данные без установления соединения. IP обеспечивает передачу данных без гарантии доставки и без сохранения порядка следования сообщений

IP просто посылает пакет в сеть. Если пакет не дошел, то IP никак об этом не оповещает и не пытается заново отправить недошедший пакет. Такие ошибки должны быть исправлены протоколами на вышестоящих уровнях

**Задачи IP:**

- **объединение сетей** с разными технологиями в одну крупную сеть
- **маршрутизация**. поиск маршрута от отправителя к получателю
- качество обслуживания

## Формат пакета:

![Формат IP пакета](img/ip_format.png)

- **Version** - Версия протокола. Текущая версия 4 (0100).
- **Header Length** - Количество 32 битных слов в заголовке пакета. Минимальная размер заголовка 20 байт, то есть в Header Length = 0x5. Наличие информации в поле Options может увеличить размер заголовка максимум на 4 байта. Если это поле заполнено не полностью, то заполненные биты покрываются 32 битными словами и незаполненная часть заполняется нулями. 
- **Type of Service** - Желаемое качество обслуживания пакета при его доставке.
- **Total Length** - Общая длина IP пакета.
- **Identifier** - Идентификатор пакета. Если пакет фрагментирован, то все фрагменты имеют одинаковый идентификатор. Это необходимо для восстановления исходного пакета.
- **Fragmentation Flags** - Флаги фрагментации. В настоящее время используется только два бита. Один показывает, фрагментирован пакет или нет, второй говорит о наличии фрагментов, следующих за текущим.
- **Fragment Offset** - Позиция фрагмента внутри пакета. Если пакет не фрагментирован то 0x0.
- **Time to Live** - количество раз, которое пакет может пройти через маршрутизаторы. При прохождении через маршрутизатор, TTL уменьшается на 1. При TTL = 0 пакет уничтожается. Такой механизм помогает, если пакет попал в "петлю". Чтобы сеть со временем не перегрузилась пакетами, они сами уничтожаются когда TTL достигает 0. 
- **Protocol** - Тип транспортного протокола, используемого при передаче (TCP или UDP)
- **Header** **Checksum** - Контрольная сумма.
- **Source** **Address** - Идентификатор отправителя пакета.
- **Destination Address** - Идентификатор получателя пакета.
- **Options and Padding** - Переменное число 32 битных слов (максимум 4 байта) используются для дополнительной информации о пакете.

# 6. Связь c канальным уровнем в ТСP/IP. Протокол разрешения адреса ARP.

ARP – Address Resolution Protocol – протокол разрешения адресов

Нужен для определения MAC-адреса устройства по его IP-адресу

Для определения MAC-адреса использует схему ARP-запрос – ARP-ответ

Алгоритм:

1. Компьютер, который хочет узнать MAC-адрес определенного компьютера в сети посылает **широковещательный** ARP-запрос на все компьютеры в сети с вопросом «У кого IP 192.168.10.43?»

2. Компьютер с IP адресом = 192.168.10.43, отправляет ARP-ответ со своим MAC-адресом

3. Компьютер-отправитель получает ARP-ответ, вытаскивает из него MAC-адрес и использует его для дальнейшей передачи данных по сети

![Формат ARP](img/ARP_format.png)

- Network Type – тип канального протокола. Ethernet = 1 
- Protocol - протокол сетевого уровня. IP = 2048 
- HAL - длина канального адреса 
- PAL - длина сетевого адреса
- Operation - тип операции. 1 = запрос. 2 = ответ.
- Source Hardware Address - MAC адрес отправителя
- Source IP Address - IP адрес отправителя
- Dest. Hardware Address - MAC адрес получателя
- Dest. IP Address - IP адрес получателя

![Формат ARP запроса](img/ARP_request.png)

![Формат ARP ответа](img/ARP_response.png)

# 8. Управляющий протокол ICMP. Сигнализирующие сообщения.

## Общие сведения

- Протокол сетевого уровня;
- Решает задачи 
  - управления,
  - нотификации об ошибках, 
  - тестирования и мониторинга;
- Инкапсулируется в IP *(да, протокол сетевого уровня в протоколе сетевого уровня)*;
- Описан в RFC792.

Задачи управления и нотификации – базовые функции сетевого уровня. При этом авторы архитектуры не зашили это в протокол IP, а выделили в отдельный протокол. Один из важнейших для стека TCP/IP.

ICMP-трафик обычно не пускают на широковещательные адреса.

## Организация протокола ICMP

Общая часть заголовка *(8, 8, 16 бит)*:

![Часть заголовка ICMP](./img/ICMP_header.png)

- Тип – тип пакета;
- Код – расшифровка типа (подтип);
- Контрольная сумма вычисляется для всего пакета.

Остальная часть пакета зависит от типа ICMP-пакета.

## Нотификационные (сигнализирующие) сообщения

Информируют отправителя о каком-либо событии в сети.

***Нотификационные сообщения фильтровать нельзя!***

### Основные типы:

- 3 – получатель недостижим *(нельзя фильтровать в своей сети)*: ![Получатель не достижим](./img/Recipient_not_reachable.png)
  - Тип (3);
  - Код *(причина «недостижимости»)*:
    - 0 – сеть недостижима;
    - 1 – узел недостижим;
    - 2 – протокол недостижим *(например, хотим доставить по* *TCP, но приемная сторона его не поддерживает)*;
    - 3 – порт недостижим *(когда никто {сервис, приложение} не прослушивает порт)*;
    - 4 – требуется фрагментация *(в* *IP-пакете установлен флаг, запрещающий фрагментацию, но сам пакет слишком большой для передачи целиком по каналу)*;
    - 5 – ошибка маршрутизации от источника *(когда не можем строго пройти через указанные адреса {строгая маршрутизация от источника в* *IP})*;
    - 6 – сеть назначения неизвестна *(обычно – попытки маршрутизации в сеть класса Е, то есть в адреса, которые не маршрутизируются в сетях* *TCP/**IP)*;
    - 7 – узел назначения неизвестен *(c**м. 6)*;
    - 8 – отправитель изолирован *(обычно – нет действующих интерфейсов для отправки пакета)*;
    - 9 – взаимодействие с сетью назначения административно запрещено *(фаервол – стоит правило* *REJECT {а вообще есть* *accept,* *deny,* *reject, но обычно во избежание перегрузки сети ответными пакетами ставят* *DENY и молча отбрасывают пакеты})*;
    - 10 – взаимодействие с узлом назначения административно запрещено *(см 9)*.
    - 11 – сеть недостижима из-за класса обслуживания *(используются разряды* *TOS, на всех маршрутизаторах внутри сети настроено управление качеством обслуживания, а мы запросили сервис выше нашего уровня)*;
    - 12 – узел недостижим из-за класса обслуживания *(см. 11)*.
  - Контрольная сумма;
  - Нулевое слово;
  - Заголовок и первые два слова пакета *(который не смогли доставить)*;
- 11 – превышено время *(нельзя фильтровать в своей сети)*: ![Превышено время](img/Time_exceeded.png)
  - Тип (11);
  - Код:
    - 0 – превышено TTL;
    - 1 – превышено время ожидания фрагмента при сборке;
  - Последнее поле содержит первую часть пакета, фрагмент которого не дошел;
- 12 – ошибка параметра *(нельзя фильтровать в своей сети)*: ![Ошибка параметра](img/Parameter_error.png)
  - Тип (12);
  - Указатель (байтовый). *(В случае, если какой-либо из промежуточных маршрутизаторов или конечный узел, проанализировав заголовок* *IP-пакета, определил, что произошла ошибка {невалидное значение поля, неверная контрольная сумма…}, он сообщает о ней, указывая номер ошибочного байта)*;
  - Последнее поле содержит первую часть пакета, в котором обнаружена ошибка;

# 9. Управляющий протокол ICMP. Управляющие и тестовые сообщения

*(!TODO)*

**Общие сведения ICMP** – 8 вопрос 

## Управляющие сообщения

Управляющие сообщения – попытка «повлиять» на саму сеть.

### Основные типы:

- 4 – подавление источника *(не синхронизирована скорость передачи данных между передатчиком и приемником. Если передатчик слишком быстро передает пакеты, приемная сторона передает следующий пакет. Передающая сторона по умолчанию снижает скорость передачи в 2 раза. Фильтровать нежелательно)*:
   ![Подавление источника](img/Source_suppression.png)
  - Тип (4);
  - Последнее поле содержит первую часть пакета, поток которого необходимо замедлить;
- 5 – изменение маршрута *(если пакет с точки зрения маршрутизатора отправляется неоптимальным путем. Отправляет ответ отправителю в качестве совета по перемаршрутизауции)*:
   ![Изменение маршрута 1](img/Route_change_1.png)
   ![Изменение маршрута 2](img/Route_change_2.png)
   *Легко подделывается. С начала 2000-х фильтруется во всех ОС. По возможности такие пакеты убиваются на всех маршрутизаторах!
   Проблемы:*
   *Функция маршрутизации реализуется протоколами маршрутизации, а не* *ICMP-протоколом (управляющим). Невозможно проконтролировать, кто создал пакет и валидный ли он.*
  - Тип (5);
  - Код *(тип переназначения маршрута)*:
    - 0 – для всей сети,
    - 1 – для узла,
    - 2 – для типа сервиса и сети,
    - 3 – для типа сервиса и узла;
  - IP-адрес маршрутизатора, *куда* необходимо присылать пакеты;
  - Заголовок IP-пакета, который (с точки зрения маршрутизатора-отправителя) идет неоптимальным путем).

## Тестовые и контрольные сообщения

Позволяют проводить диагностику сети.

Обычно идут парами «запрос-ответ».

### Типы:

- Запрос эха (8) и ответ на запрос эха (0) (*ping* и *pong. Проверка работоспособности удаленного узла. Используется в утилитах типа* *ping и ей подобных, позволяющих проверить достижимость узла в сети)*:
   ![Запрос эха](img/Echo_request.png)
   Идея: станция посылает удаленной станции пакет с типом 8, промежуточные маршрутизаторы доводят его до последней станции. Та, получив его, уничтожает, в ответ формирует такой же пакет с типом 0, а в поле данных копирует те необязательные данные, которые были в поле эхо-запроса, после чего посылает обратно.
   *Обычно в своей сети разрешаем 8 на выход и 0 на вход. Остальное отрубаем. Иногда – ставим прокси (**ICMP-сервер**), чтобы он формировал фейковые сообщения за все компьютеры в сети.*
  - Тип (8 или 0);
  - Идентификатор (для различения пар потоков *ping*-ов и *pong*-ов. По нему определяется процесс, которому отдают ответный трафик);
  - Последовательный номер *(номер пакета в серии. Для посылки не одного, а нескольких пакетов. Для сопоставления ответа запросу)*;
  - Необязательные данные (тестирование на прохождение пакетов данных определенного размера по каналу связи. Могут расширить *ICMP-пакет* до 64 Кб. Большие пакеты могут фильтроваться по размеру из-за имевшей место атаки «*ping of death*»);
  
- Запрос временной метки (13) и ответ на запрос временной метки (14):
   ![Запрос временной метки 1](img/Timestamp_request_1.png)
   ![Запрос временной метки 2](img/Timestamp_request_2.png)
   *(позволяют определить временные параметры функционирования сети)*
  - Идентификатор – номер потока сообщений;
  - Последовательный номер – номер пакета в потоке;
  - (T1) **Временная метка отправителя** заполняется источником *(время, когда пакет улетел из отправителя)*;
  - (T2) **Временная метка приема** фиксируется при получении запроса приемником *(время, когда пакет пришел на приемную станцию)*;
  - (T3) **Временная метка передачи** заполняется приемником *(когда был послан ответ)*;
  - (T4) Еще мы знаем время, когда мы получим ответ обратно от приемника;
  - Проблемы:
    - Синхронизация часов;
    - Фильтрация.
  
- Запрос маски адреса (17) и ответ на запрос маски адреса (18):
   ![Запрос маски адреса](img/Address_mask_request.png)
   *(Чаще всего – чтобы узнать топологию удаленной сети. Считается опасным, не рекомендуется к использованию вне текущей сети)*.

  - Идентификатор – номер потока сообщений;

  - Последовательный номер – номер пакета в потоке;

  - Маска – записанная маска адреса приемника.

# 10. Адресация приложений. Понятие портов.

## Понятие портов

- Порт – уникальный номер приложения на узле, использующего конкретный транспортный протокол
- В TCP/IP порт – 16 разрядов (0...65535)
- Приложение идентифицируется сокетом:
  - IP-адресом узла
  - Типом транспортного протокола
  - Номером порта
- Примеры:
  - TCP-сокет: 195.19.212.13:80
  - UDP-сокет: 195.19.212.10:53
- Есть некоторые правила по умолчанию, которые все стараются соблюдать: 
  - Сервер обычно использует фиксированные номера портов из диапазона от 0 до 1023.
  - Клиент обычно использует непривилегированные номера портов из диапазона 1024+. В некоторых ОС для того, чтобы выдать приложению порт меньше 1024, требуется, чтобы приложение имело достаточно привилегий и прав. 
- Философия, которую пыталась сделать IANA, а теперь ICANN: 
  - 1024 адреса – это зарезервированные адреса, которые мы выдаём всем известным сервисам, а то, что выше 1024 – это свободно распространяемые номера портов.
  - Для сервера важно иметь предопределённый номер, потому что мы должны из разных узлов должны к нему обращаться и знать его номер, нам важно, чтобы он был фиксированный и публичный. А для клиента неважно, чтобы его номер был фиксированный, потому что к клиенту никто напрямую не обращается за редким исключением. Поэтому адрес клиента не должен быть публичным, его можно выдавать временно на 1 сеанс, что и сделано в большинстве протоколов.

### Транспортный протокол UDP

Является транспортным механизмом архитектуры TCP/IP.

**UDP** – User Datagram Protocol, протокол без установления соединения.

Дейтаграмный обмен:

- Не гарантирует последовательность доставки
- Не обеспечивает квитирование
- Реализуется протоколом UDP

Особенности (по сравнению с другими):

- Более высокая скорость
- Меньшая надежность

Зарезервирован номер 17 в IP-пакете

Для адресации используются UDP-порты

Сервер обычно использует фиксированные номера портов (1-1023)

Клиент обычно использует непривилегированные номера портов (1024-65535)

**Формат пакета:**

| Порт отправителя | Порт получателя   |
| ---------------- | ----------------- |
| Длина сообщения  | Контрольная сумма |
| Данные           |                   |

Длина сообщения включает заголовок и данные.

Контрольная сумма:

- Вычисляется по всему пакету
- Если контрольная сумма равна 0, то она не вычислялась (для сверхнадежного канала)
- Контрольная сумма вычисляется с учетом псевдозаголовка:

![subheader_sum](img/subheader_sum.png)

Приложения, использующие UDP:

- TFTP – 69
- DNS – 53
- SNMP – 161, 162
- BOOTP, DHCP – 67, 
- 68RIP - 520

# 14. Транспортный протокол SCTP

SCTP – Stream Control Transmission Protocol (протокол передачи с управлением потоком). Относительно новый транспортный протокол.
Первым его стандартом был RFC2960, 2002г.
Нынешний стандарт RFC4960, сентябрь 2007г.

Основная идея создания протокола была объеденить в себе достоинства и исправить недостатки двух других известных транспортных протоколов (TCP и UDP).

Одними из главных нововведений SCTP были многопоточность, защита от DdoS атак и multi-homing(синхронное соединение между двумя хостами по двум и более независимым физическим каналам) (дополнительно после формата пакетов).

Целый пакет состоит из общего заголовка(12 байт=64 бита) и субпакетов (чанков). Каждый чанк же в свою очередь состоит из своего заголовка и данных.

### Формат общего заголовка:

![sctp_header](img/sctp_header.png)

Где:

- Verification tag – метка для проверки
   отправителя пакета (32-битное случайное значение, созданное во время инициализации, чтобы отличать устаревшие пакеты от предыдущего соединения)
- Check Sum – контрольная сумма 

### Формат чанков:

![chunks](img/chunks.png)

Под тип выделен один байт,значит возможно 255 различных типов. На данный момент в RFC определены 15 типов. 0 означает, что чанк несет полезные данные, остальные — служебные.

Под флаги тоже 8 бит, состав флагов определяется типом чанка.

Длина чанка — 0 ... 65535, общая длина субпакета с заголовками.

### Безопасное установление соединения:

![tcp_procedure](img/tcp_procedure.png)

В TCP трехэтапный хэндшейк, в чем есть одна потенциальная уязвимость, обусловленная тем, что нарушитель, устанавливая фальшивые IP-адреса отправителя, может послать серверу множество пакетов SYN. При получении пакета SYN сервер выделяет часть своих ресурсов для установления нового соединения. Обработка множества пакетов SYN рано или поздно затребует все ресурсы сервера и сделает невозможной обработку новых запросов. Такой вид атак называется «SYN-флуд».

Протокол SCTP защищён от подобных атак с помощью механизма четырёхэтапного квитирования (four-way handshake) и вводом маркера (cookie). По протоколу SCTP клиент начинает процедуру установления соединения, посылая пакет INIT. В ответ сервер посылает пакет INIT-ACK, который содержит маркер (уникальный ключ, идентифицирующий новое соединение). Затем клиент отвечает посылкой пакета COOKIE-ECHO, в котором содержится маркер, полученный от сервера. Только после этого сервер выделяет свои ресурсы новому подключению и подтверждает это отправкой клиенту пакета COOKIE-ACK.

### Многопоточность

![sctp_thread_association.png](img/sctp_thread_association.png)

Термин «многопоточность» (англ. *multi-streaming*) обозначает способность SCTP параллельно передавать по нескольким независимым потокам *сообщений*. Например, мы передаём несколько фотографий через HTTP-приложение (например, браузер). Можно использовать для этого связку из нескольких TCP-соединений, однако также допустима *SCTP-ассоциация* (англ. *SCTP-association*), управляющая несколькими потоками сообщений для этой цели. Потоки являются однонаправленными, то есть передают информацию только в одном направлении (картинка выше является неточной). 

TCP достигает правильного порядка байт в потоке, абстрактно назначая порядковый номер каждой отосланной единице, а упорядочивая принятые байты, используя назначенные порядковые номера, по мере их прибывания. С другой стороны, SCTP присваивает различные порядковые номера сообщениям, посылаемым в конкретном *потоке*. Это разрешает независимое упорядочивание сообщений по разным потокам. Так или иначе, многопоточность является опцией в SCTP. В зависимости от желаний пользовательского приложения, сообщения могут быть обработаны не в порядке их отправления, а в порядке их поступления. 

## Другие достоинства SCTP:

**Multihoming** (Использование множественных интерфейсов, мультидомность по Ицыксоновски) - Допустим, у нас есть два хоста. И хотя бы один из них имеет несколько сетевых интерфейсов, и соответственно несколько IP-адресов. В TCP, понятие «соединение» означает обмен данными между двумя точками, в то время, как в SCTP имеет место концепция «ассоциации» (англ. *association*), обозначащая всё происходящее между двумя хостами

**Механизмы валидации и проверки подлинности -** Защита адресата от flood-атак (технология 4-way handshake), и уведомление о потерянных пакетах и нарушенных цепочках.

![sctp_validation.png](img/sctp_validation.png)

## Из недостатков

Бóльшая занимаемая полоса, то есть относительный объём служебного трафика больше, чем при использовании TCP/UDP. 

![sctp_features](img/sctp_features.png)

# 15. Маршрутизация в TCP/IP. Маршрутизаторы и шлюзы. Процесс доставки пакетов в сети.

**Internet Protocol** служит для пересылки ip-datagrams от ip-адреса отправителя до ip-адреса получателя (адреса при пересылке остаются неизменными, в отличии от аппаратных адресов). Маршрутизация же является ключевой функцией IP, т.к. необходима для поиска маршрутки доставки этого пакета.

### Маршрутизация

- Функция сетевого уровня
  - Заключается в поиске оптимального маршрута для доставки пакетов через сеть от ip-адреса узла-отправителя до ip-адреса узла-получателя 
  - Сбор и хранение информации о других маршрутизаторах и хостах в сети
- Маршрутизация:
  - Индивидуальная (два узел устанавливают между собой отдельный маршрут)
  - Групповая (один узел устанавливает маршруты с группой других и пересылает данные членам группы)

- В TCP/IP сетях маршрутизация является частью протокола IP (Internet Protocol) и используется в сочетании с другими службами сетевых протоколов для обеспечения передачи данных между узлами, расположенными в разных сегментах более крупной TCP/IP-сети.

### Маршрутизаторы и шлюзы

- Другие названия:
  - Шлюз
  - Router
  - Gateway
- Устройство сетевого уровня, реализующее функции маршрутизации (обеспечивающее доставку пакетов от одного узла сети к другим)
- Отличие маршрутизатора от обычного сетевого узла – пересылка входящих пакетов, у которых адрес назначения не совпадает с локальными адресами узла
- IP-forwarding. Переадресация IP, также известная как интернет-маршрутизация, представляет собой процесс, используемый для определения того, по какому пути может быть отправлен пакет или дейтаграмма. Процесс использует информацию о маршрутизации для принятия решений и предназначен для отправки пакета по нескольким сетям.
- Виды маршрутизаторов:
  - Аппаратные (маршрутизатор, router)
  - Программно-аппаратные (шлюз, gateway)



### Аппаратные маршрутизаторы (маршрутизатор)

- Особенности:

  - Поддержка различных канальных сред
  - Наличие нескольких сетевых интерфейсов
  - Высокая производительность
  - Высокая надежность
  - Хорошая защищенность
  - Дополнительные функции:
    - Фильтрация
    - Трансляция адресов
    - Сбор статистики

  - Обычно высокая стоимость

- Производители:
  - CISCO
  - Intel
  - HP
  - Dlink

### Программно-аппаратные маршрутизаторы (шлюз)

- Реализуются функциями ОС общего назначения
- Характеризуются
  - Невысокой производительностью
  - Невысокой стоимостью
  - Могут совмещать функции с обычными функциями ОС

## Процесс маршрутизации

В процессе маршрутизации на стороне отправителя данные проходят все 7 уровней модели ISO/OSI сверху-вниз постепенно инкапсулируясь на каждом из уровней. В итоге получается такой большой «конверт с конвертами», который пересылается получателю. На стороне получателя данные постепенно декапсулируются («конверт» постепенно раскрывается) на каждом уровне, пока идут снизу-вверх и пока не достигнут прикладного уровня.

![Маршрутизация на OSI](img/Routing_OSI.jpg)

- A, B – компьютеры
- R1, R2 – маршрутизаторы
- 1–7 – это уровни в OSI/ISO
- Компьютер использует все 7 уровней модели, а маршрутизатор только 3, так как их достаточно, чтобы продолжить маршрут в любой сети.

# 16. Статическая маршрутизация. Таблицы маршрутизации.

**Статическая маршрутизация** – вид маршрутизации, при котором маршруты указываются в явном виде при конфигурации маршрутизатора администратором. Вся маршрутизация при этом происходит без участия каких-либо протоколов маршрутизации. Статический маршрут хранится в таблицах до выключения. 

При задании статического маршрута указывается:

- Адрес сети (на которую маршрутизируется трафик), маска сети
- Адрес шлюза (узла), который отвечает за дальнейшую маршрутизацию (или подключен к маршрутизируемой сети напрямую)
- (опционально) метрика ("цена") маршрута.

## Достоинства:

- Лёгкость отладки и конфигурирования в малых сетях
- Отсутствие дополнительных накладных расходов (из-за отсутствия протоколов маршрутизации)
- Мгновенная готовность (не требуется интервал для конфигурирования/подстройки)
- Низкая нагрузка на процессор маршрутизатора
- Предсказуемость в каждый момент времени

## Недостатки:

- Очень плохое масштабирование
- Низкая устойчивость к повреждениям линий связи
- Отсутствие динамического балансирования нагрузки
- Необходимость в ведении отдельной документации к маршрутам

В реальных условиях статическая маршрутизация используется в условиях наличия шлюза по умолчанию (узла, обладающего связностью с остальными узлами) и 1-2 сетями.

## Таблицы маршрутизации

![Таблицы маршрутизации](./img/Route_table.png)

Атрибуты маршрутных записей:

- Сеть/узел назначения
- Сетевой интерфейс
- Маршрутизатор
- Метрика маршрута
- Флаги

**Псевдомаршруты** – дополнительные записи в таблице маршрутизации, которые используются для унификации процедуры поиска маршрута. Типы:

- Псевдомаршрут на IP-адреса собственных интерфейсов
- Псевдомаршрут на подключенные IP-сети

**Маршрут «по умолчанию»** – специальный маршрут, которые используется в случае отсутствия явных маршрутов на целевую сеть, обозначение: 0.0.0.0/0.0.0.0

Утилита route предназначена для просмотра и управления таблицей маршрутизации.

В некоторых системах поддерживается несколько таблиц маршрутизации, в таких таблицах используется коммутация **по адресу источника** – в зависимости от адреса источника выбирается подчиненная таблица маршрутизации.

# 17. Маршрутизация. Виды маршрутизации. Алгоритм выбора маршрута в РС.

[Маршрутизация - 15 вопрос](#15.-маршрутизация-в-tcp/ip.-маршрутизаторы-и-шлюзы.-процесс-доставки-пакетов-в-сети.)

Маршрутизацию можно классифицировать по нескольким признакам:

**По адаптивности**

- Статическая маршрутизация ([Вопрос 16](#16-статическая-маршрутизация.-таблицы-маршрутизации.))
- Динамическая маршрутизация ([Вопрос 17](#17.-динамическая-маршрутизация.-алгоритм-беллмана-форда-поиска-кратчайшего-пути.))
- Маршрутизация "от источника" (в зависимости от адреса источника выбирается подчиненная таблица маршрутизации)

**По месту маршрутных вычислений**

- Централизованные  (выбор маршрута для каждого пакета осуществляется сервером управления сетью, а узлы сети реализуют за данную маршрутизацию)
- Децентрализованные (управления маршрутизацией осуществляется узлами, обладающие соответствующим функционалом)

**По требуемой информации**

- Локальные (адрес локальной сети)
- Глобальные (адрес глобальной сети)
- Смешанные (обеспечивается доступ как в локальную сети, так и в глобальную)

Задача оптимальной маршрутизации –  найти оптимальный путь данных до получателя. 

Обеспечиваемая оптимальность

- Минимальное время доставки 
- Минимальная стоимость доставки 
- Минимальная задержка
- ...

При выборе статической маршрутизации адреса назначаются вручную заранее в таблицу маршрутизации, по которой и будет выбираться, на какой интерфейс отправить пакет с соответствующей адресной информацией ([Вопрос 16](#16-статическая-маршрутизация.-таблицы-маршрутизации.)).

[Динамические алгоритмы - Вопрос 18](#18.-динамическая-маршрутизация.-алгоритм-беллмана-форда-поиска-кратчайшего-пути.)

# 18. Динамическая маршрутизация. Алгоритм Беллмана-Форда поиска кратчайшего пути.

В **динамической адресации** таблица маршрутизации обновляются автоматически путем сбора информации при помощи обмена информации между служебными программами (демоны маршрутизации) на разных узлах. Таким образом динамическая маршрутизация учитывает множество изменяющихся параметров сети:

- Топология сети 
  - Появление новых узлов 
  - Появление новых каналов 
  - … 
- Каналы связи 
  - Выход из строя канала 
  - Ввод в строй канала 
- Узлы сети 
  - Выход из строя маршрутизатора 
  - Ввод в строй маршрутизатора 
- Изменение нагрузки в сети

В случае динамической маршрутизации задача заключается в поиске оптимального пути для пакета **в данный момент времени**. Задача сводится к задаче поиска пути на графе.

## Алгоритм Беллмана-Форда поиска кратчайшего пути.

### Краткое описание

Алгоритм оценивает расстояние до каждого из N узла начиная с *первого*. Оценка высчитывается исходя из веса ребра r<sub>i,j</sub> (переход между вершинами i и j). На каждую итерацию ставится ограничение переходов между узлами. В конце h-й итерации фиксируются минимальные уникальные пути D<sub>(h), i</sub> (от 1го узла до посещенного узла i) длинной не более h переходов. Перебор останавливается при достижении количества переходов равному количеству ребер (а если точнее N - 1) или если оценка перестала изменяться.

### Алгоритм

- Шаг 1. Начальные условия 
  - Граф дополняется до полного. Вес новых дуг - ∞. 
  - h := 0 
  - Вводится начальная разметка: 
    - D<sub>(h), 1</sub> = 0
    - D<sub>(h), i</sub> = ∞, i ≠ 1
- Шаг 2. Перерасчет оценок 
  - Для всех i: D<sub>(h+1), i</sub> = minj [D<sub>(h), j</sub> + r<sub>i,j</sub>]
  - h := h + 1 
- Шаг 3.
  - Если h = N – выход 
  - Если оценки не изменились – выход 
  - Иначе – переход к шагу 2

![bellman-ford1](img/bellman-ford1.png)

![bellman-ford2](img/bellman-ford2.png)

![bellman-ford3](img/bellman-ford3.png)

![bellman-ford4](img/bellman-ford4.png)

![bellman-ford5](img/bellman-ford5.png)

![bellman-ford6](img/bellman-ford6.png)

Общее число операций:

- N – число вершин 
- N-1 – число шагов 
- N – операций при минимизации на каждом шаге 
- W = O(N3) 

Достоинства алгоритма: 

- Хорошо распараллеливается 
- Просто реализуется 
- Не требует ресурсов памяти 
- Требуется информация только о соседних вершинах 
- Часто заканчивается раньше N-1 итерации 

Недостатки алгоритма: 

- В худшем случае количество операций - ~N<sup>3</sup>

# 19. Динамическая маршрутизация. Алгоритм Дэйкстры поиск кратчайшего пути.

[Динамические алгоритмы - Вопрос 18](#18.-динамическая-маршрутизация.-алгоритм-беллмана-форда-поиска-кратчайшего-пути.)

## Алгоритм Дэйкстры поиска кратчайшего пути (Shortest Path First).

### Краткое описание

Каждой вершине из V сопоставляется метка (минимальное известное расстояние от этой вершины до 1й). Изначально у 1й вершины метка равна 0, а у всех остальных бесконечности. Далее итеративно обходятся вершины. Из каждой вершины (начиная с 1й) оцениваются ребра к другим вершинам. На основании этой оценки проверяется, можно ли при помощи нового пути, включающего это ребро, сократить время до узла (новое значение сравнивается с меткой узла, если новое значение меньше - оно заменяется). Перебор заканчивается после обхода всех узлов.

### Алгоритм

- P - множество помеченных вершин (для которых найден кратчайший маршрут)
- Si – текущая оценка пути от 1-ой до i-ой 
- m – номер текущего шага

- Шаг 1. Начальные условия  
  - Множество P: P={1} 
  - Оценка пути: 
    - S1 := 0  
    - Si := r<sub>1,i</sub> 
    - m = 1 
- Шаг 2. 
  - Sn := min<sub>j</sub> S<sub>j</sub> 
  - P := P ∪ {n} 
  - Для всех i ∉ P: 
    - Si := min (Si , Sn + rn,i) 
  - m := m+1 
- Шаг 3. 
  - Если m = N -> выход 
  - Иначе – переход к шагу 2

![Dijkstra1](img/Dijkstra1.png)

![Dijkstra2](img/Dijkstra2.png)

![Dijkstra3](img/Dijkstra3.png)

![Dijkstra4](img/Dijkstra4.png)

![Dijkstra5](img/Dijkstra5.png)

![Dijkstra6](img/Dijkstra6.png)

Общее число операций: 

- N-1 – число шагов  
- N – операций при пересчете оценок на каждом шаге 
- W = O(N2) 

Достоинства алгоритма: 

- Высокая скорость (~N<sup>2</sup>) 

Недостатки алгоритма: 

- Плохо распараллеливается 
- Требуется иметь информацию о топологии всей сети 
- Требует существенных ресурсов памяти (~N<sup>2</sup>)

# 27. Архитектура ДНС. Прямой поиск.

#### Архитектура:

DNS (domain name system) - распределённая иерархическая система, чаще всего используется для преобразования доменного имени в IP-адрес или для обеспечения работы почтовой системы.

**Структура:**

- Вся система имеет древовидную структуру, корневой элемент которой - ".", обслуживается 13 серверами (обозначаются буквами a-m) или зеркалами этих серверов (в РФ нет корневых серверов, только зеркала).
- Всё дерево имён поделено на участки ответственности - "зоны", каждая из которых обслуживается своим сервером. 
- Сервер, который ответственен за данную зону, называется авторитетным.
- DNS-клиент всегда обращается к серверу через resolver

Для каждой зоны должно быть несколько авторитетных серверов, находящихся в разных подсетях (для надёжности):

- Первичный (один)
  - содержит оригинал информации о подконтрольной зоне (e.g. в локальной сети)
- Вторичный (несколько) 
  - содержит копии информации о подконтрольной зоне (e.g. арендованный у хостинга, у провайдера)
  - периодически обновляет информацию
  - в конфигурации вторичного сервера указывается, что делать, если первичный не отвечает

**По способу ответа DNS-серверы бывают:**

- Рекурсивные
  - САМИ выполняют всю процедуру поиска
  - Кэшируют полученный результат
- Нерекурсивные
  - Перенаправляют на сервер с необходимой информацией
  - Не занимаются кэшированием

Стоит учесть, что рекурсивный поиск - долгая и более ресурсозатратная процедура, поэтому чем "выше" мы поднимаемся, тем меньшая вероятность встретить рекурсивный сервер. Все корневые серверы (".") и все домены 1 уровня - нерекурсивные.

### **Прямой поиск:**

Пример: мы (office.school.server.ru) хотим обратиться к сайту (www.support.ibm.com). Тогда первое (некэшированное) обращение будет выглядеть следующим образом:

- Resolver на нашем компьютере обращается к сохранённому в конфигурации TCP/IP DNS-серверу
  - DNS-серверы по умолчанию имеют префикс ns, допустим, наш сохранённый - ns.school.server.ru
- ns.school.server.ru - рекурсивный. Первый его запрос - к корневому серверу ("." - e.g. a.root-servers.net)
- Корневой сервер нерекурсивен - он перенаправит нас на сервер, ответственный за домен "com"
- Обращаемся к домену "com" - он нерекурсивен, отправит нас на сервер, ответственный за ibm.com (ns.ibm.com)
- ns.ibm.com - рекурсивный - сам обращается к DNS-серверу зоны support.ibm.com (ns.support.ibm.com)
- www - последний уровень домена - ns.support.ibm.com возвращает информацию на ns.ibm.com, попутно её кэшируя
- ns.ibm.com возвращает информацию на ns.school.server.ru, попутно её кэшируя
- ns.school.server.ru возвращает информацию нам, попутно её кэшируя

При последующем обращении по тому же адресу (пока не истекло время жизни кэшированной записи) ns.school.server.ru будет сразу возвращать нам требуемый адрес. При обращении по тому же адресу после истечения времени жизни записи вся процедура будет повторена снова.

# 28. База данных DNS. Ресурсные записи DNS. Адресные записи, записи о сервере имен.

База данных DNS состоит из отдельных ресурсных записей (Resource record - RR), каждая из которых хранит определённый тип информации.
**Записи имеют следующие поля:**

- Имя
  - При неуказанном имени будет использовано предыдущее
- Класс записи (почти всегда IN - internet)
- Тип записи
  - Основные типы: A, AAAA, NS, MX, etc.
- Время актуальности
  - Время, которое запись может храниться в кэше
  - При отсутствии - значение по умолчанию 
- Параметры записи
  - Зависят от типа записи
    - При описании часто используется формат BIND
    - A: Доменное имя узла, адрес узла
      - school IN A 195.19.212.16  на сервере ns.server.ru -> school.server.ru по адресу 195.19.212.16
    - NS: Имя домена, адрес сервера имён
      - school.server.ru. IN NS 195.19.212.13 -> скорее всего, вторичный name-server для домена server.ru.

# 29. База данных DNS. Главная ресурсная запись. Маршрутизация электронной почты.

**База данных DNS** состоит из ресурсных записей – записи помогают выполнять запросы. Ресурсные записи хранят определенный тип информации, каждая запись содержит определенное количество полей.

Главная ресурсная запись **SOA** (start of authority). Предназначена для описания параметров домена. Имеет много параметров, так как является неким *паспортом* домена:

- **Имя домена** – имя домена, для которого сформирована главная запись
- **Имя первичного DNS-сервера** – сервер, который отвечает за адрес домена
- **Почтовый адрес администратора** – связь при проблемах
- **Серийный номер зоны (Serial)** – уникальный ID текущей зоны, увеличивается при изменении зоны
- **Период обновления(Refresh)** – время в секундах, как часто вторичный сервер должен обращаться к первичному
- **Время валидности данных(Expire)** – если первичный сервер не отвечает, Expire отвечает на запросы о зоне информации
- **Период повторных попыток (Retry)** - указывает задержку перед следующим обращением после неудачной попытки
- **Значение по умолчанию (DefaultTTL)** - Время жизни для всех записей в зоне

Главная ресурсная запись одна на зону.

![Пример SOA](./img/Example_SOA.png)

AXFR – копируется вся зона.

## Запись о сервере эл.почты

- DNS используется для маршрутизации почты
- Почтовый домен не всегда связан с конкретным IP адресом.
- MX связывает IP- адреса и почтовые домены
- Приоритет задает желаемое качество доставки.

![Примиер записи о сервере почты](./img/Email_note.png)

# 30 База данных DNS. Записи о псевдонимах, сервисах.

**Запись о псевдониме** – позволяет выдать новое имя уже известному адресу.

![Запись о псевдониме](./img/Alias_note.png)

В реальном мире мало веб-серверов с именем www, практически всегда используется псевдоним. В конце 90-х появились веб-хостинги, в этом случае псевдоним используется как переключатель, что позволяет на одном физическом IP разместить неограниченное количество виртуальных адресов. Web-server узнает, к которому узлу обращаться благодаря особенностям http (URL хранится в заголовке http).

НЕ ИСОЛЬЗУЮТСЯ ДЛЯ МАРШРУТИЗАЦИИ ПОЧТЫ

## Запись о сервисе

Запись анонсирует наличие сервиса и его местонахождение. Запись о сервисе – относительно новая запись, расширяет идею MX, делает универсальным обращение к какой-либо службе. Вес используется чтобы распределять нагрузку между сервисами.

![Запись о сервисе](./img/Service_note.png)

# 31. DNS. Обратный поиск.

Если прямой поиск в DNS — по домену найти ip адрес, то обратный поиск — обратная задача: по ip адресу найти доменное имя.
Цель обратного поиска — убедиться в подлинности доменного имени, т. е. Это используется в целях безопасности. 

### Как организуется обратный поиск.

<u>Прямой поиск:</u> мы идем по дереву имён, начиная с ближайшего к нам днс сервера, а потом через корневой находим необходимый сервис в соответствии с доменным именем.

<u>Обратный поиск:</u> здесь ситуация гораздо хуже у нас нет домена, у нас есть ай пи адрес разработчики не стали разрабатывать отдельный протокол обратного днс.

Они свели задачу к уже ранее решенным и по сути для обеспечения обратного поиска используют прямой поиск.

для преобразования создан специальный домен: In-addr.arpa, который отвечает за обратное преобразование. структура имен в этом домене соответствует октетам айпи адреса в обратном порядке.

При запросе имени для адреса X.Y.Z.T строится запрос для имени:

- T.Z.Y.X.in-addr.arpa
- Такой запрос обслуживается как прямой

превращается в символическое имя, где в обратном порядке записаны десятичные октеты и получаем стандартный домен. И по нему делается запрос. По какой ресурсной записи? Ptr

### PTR

Введена новая ресурсная запись: PTR. Обратный смысл по отношению к адресной записи. Задача – показать каким именам соответствуют какие имена. 

Обеспечивает преобразование имен из домена in-addr.arpa. в доменное имя 

Запись PTR: Использовано для обратного преобразования имен из домена in.addr.arpa в доменное имя. 

<u>Параметры:</u>

1) Имя узла – перевернутый ip адрес. 

2) Доменное имя узла 

<u>Формат bind</u> - in-addr-name IN PTR name

<u>Примеры:</u> 11.12.19.195.in-addr.arpa. IN PTR ya.ru. - Адресу 195.19.12.11 соответвует ya.ru

16 IN PTR office.school.server.ru - Для всей сети класса с описать обратное преобразование, можно использовать только последний октет. 

### Система bind

Самая популярная система организации днс в мире. эта система разработана очень давно. изначально в университете беркли. Предназначена для организации базы данных днс.

 Если хотим организовать систему днс, обслуживающие домен: 

1) Создаем главный файл конфигурации. Описываются все зоны, которые ведутся данным сервером. Типы зон – первичный (сами отвечаем за эту зону ) и вторичная (копируем данные с первичного)

2) Файл прямого преобразования. Для зоны, которую мы ведем, содержатся все адресные записи, записи о name сервере, записи soa(главная запись домена) , необходимое число записей mx/ cname

3) Файлы обратного преобразования. Должно быть столько, сколько обратных зон. В нем записи soa, ns, ptr,  

4) Файл кэша корневых серверов. Файл, где указаны текущие ip адреса 13 корневых серверов. 

5) Файл обратного преобразования для локальной зоны – 127 0 0 1, если хотим получить обратное имя, то должны завести зону, где будет единственная запись, и выдавать localhost

Чтобы DNS заработал нужно правильно зарегистрировать зону, правильно проделегировать права и т д. 

### Проблемы: 

1) если я хочу полностью ввести систему днс. то мне нужно отдельно ввести прямой домен (school.server.ru). Я должен завести домен, авторитетный сервер, завести в нем первичные вторичные днс серверы, которые отвечают запросы. но если я хочу чтобы работало обратное преобразование, я должен еще завести еще одну зону, но например в данном случае зона 12 19 195.in-addr.arpa и в ней тоже завести несколько днс серверов которые отвечают за эту зону и тоже правильно зарегистрировать и делегировать. 

<u>Вопрос:</u> Если не одна сеть класса с, а например 10. Доменное имя у всех одно? Как сделать, чтобы обратный днс тоже работал? Какие зоны нужно ввести?

**Для прямого:** 2к пк в сети. В файле прямой зоны (schoolserverru) будет 2.5к запись. Слева один домен, справа 10 сетей класса с. 

**Для обратного:** нужно будет сделать 10 зон для каждого класса сетей.  

<u>Вопрос:</u> Маленькая компания. Всего 16 ip адресов. Как ввести свою обратную зону? Не могу ввести, так как ей пользуются другие. Что делать? Провайдер должен предоставить. Но если часто меняем ip адреса, то постоянно дергаем провайдера

# 32. DNS. Динамические обновления; нотификации об изменениях; инкрементальные обновления.

## Динамические обновления:

**Причина появления:** наличие динамических систем управления адресами DHCP

DNS Dynamic Update – RFC 2136

Позволяет внешним авторизованным источникам менять адреса.

**Принцип работы:** Авторизованный клиент посылает DNS серверу запрос об изменении информации о ресурсной записи. Если сервер не первичен, то запрос пересылается наверх. Когда дошли до первичного DNS, то первичный сервер модифицирует свою базу данных, изменяет серийный номер зоны. Через какое то время вторичные серверы получают от первичного обновленную информацию.

## Нотификация об изменениях:

Асинхронное информирование об изменении информации.

Раньше вторичные серверы получали информацию от первичных синхронно, то есть, в соответствии с записью зоны синхронно получали обновление. Это не всегда удобно, хотелось бы получать уведомления об изменениях, данных от первичного сервера как можно раньше. Например, в случае динамических обновлений, надо чтобы эту информацию быстро узнал интернет.

DNS Notify – RFC 1996

Если включена эта опция, то первичный сервер посылает обновление всем известным ему вторичным серверам. Далее вторичные посылают другим вторичным. Каждое сообщение об нотификации подтверждается. Когда дошли «до конца» , вторичные серверы осуществляют запрос зоны как при периодическом обновлении.

## Инкрементальная передача зон (инкрементальные обновления):

Классический DNS передавал всю зону. То есть если что-то изменилось, то первичный передаёт вторичному весь огромный файл зоны, сколько бы там записей не было. При динамических обновлениях происходит слишком много трансферов зон.

Для уменьшения передаваемой информации, передаётся только инкремента (приращение) зоны, вместо всей зоны. В запросе вторичный указывает серийный номер зоны, которая у него есть, а первичный вычисляет разницу содержимого и высылает её.

Тип запроса изменяется на **IXFR**.

# 33. Автоматизированная настройка параметров. Протоколы BOOTP и DHCP.

## Управление сетевыми параметрами.

Два подхода:

1) Ручная настройка: вручную задаются IP адреса, маски, DNS серверы и прочие маршрутизаторы.

2) Автоматизированная настройка: перечисленные выше параметры настраиваются автоматически либо автоматизировано.

Идея автоматизированной настройки пришла от того, что когда имеется большая компьютерная сеть, то снабжать всех пользователей инструкцией как и что надо настроить, для администратора становится очень сложно. Тем более при изменении, какого либо параметра придется объяснять ещё раз. Появилась идея сделать так, чтобы компьютер сам настраивал параметры забирая их из сериализованного хранилища.

Для этого было разработано несколько протоколов:

- RARP (Reverse Address Resolution Protocol) – устаревший протокол

- BOOTP (Bootstrap Protocol) – устаревший протокол

- DHCP (Dynamic Host Configuration Protocol)

## RARP:

Описан в RFC 903

Принцип работы: в сети должен быть RARP сервер, при включении в сеть клиент делает запрос на этот сервер. В ответ приходит IP адрес и присваивается сетевому адаптеру. Разделяет один формат пакетов с ARP.

Используется только для получения IP, чего недостаточно в современных сетях.

## BOOTP:

Описан в RFC 951, 1533, 1542

Принцип работы: в сети должен быть BOOTP сервер. В момент, когда бездисковая или автоконфигурируемая станция собирается загрузиться, делается широковещательный запрос по протоколу BOOTP к этому серверу. BOOTP :

1) IP адрес.

2) Маска сети.

3) Маршрутизатор по умолчанию. 

Выдается достаточно параметров, чтобы компьютер стал автономным, и всё остальное, при необходимости, мог загрузить из сети.

Протокол позволяет делать цепочку BOOTP ретрансляторов до BOOTP сервера. То есть, если в вашей сети нет BOOTP сервера, то отправляется запрос к BOOTP ретранслятору, ретранслятор отправляет запрос дальше, пока не будет достигнут BOOTP сервер и не будет получена информация.

Реализация: у BOOTP сервера имеется статическая таблица соответствий MAC адресов и параметров узла. То есть, администратор, когда хочет сконфигурировать BOOTP сеть, то заходит на сервер, и, зная все компьютеры в сети, для каждого из них прописывает необходимые параметры.

## DHCP:

Протокол разработан компанией Microsoft

Описан в RFC 2131, 2132

Разработан не как самостоятельный протокол, а как расширение BOOTP протокола. Все новые, получаемые дополнительно поля, располагаются в поле опций протокола BOOTP.

Поддерживается 3 режима:

1) Ручное распределение адресов: точно такое же, как в BOOTP, администратор пишет соответствие MAC адресов и выдаваемых параметров.

2) Автоматическое распределение: формируется пул адресов, которые раздаются клиентам по мере их подключения. После чего выданные данные заносятся в таблицу, и в будущем никому кроме выбранной станции, адрес не выдается. Количество подключаемых станций соответствует количеству свободных адресов. Не подходит для современного интернета.

3) Динамическое распределение адресов: адреса не закрепляются за конкретным устройством навсегда, выдаются в аренду, по истечению срока аренды, адрес становится вновь свободным и может быть выдан любому устройству, которое захочет подключиться.

Информация передается через опции протокола BOOTP.

### Типы опций:

1) Базовые параметры:

   - маска сети

   - default gateway (маршрутизатор по умолчанию)

   - DNS сервер

   - название вашего узла (текстовое)

   - название домена по умолчанию

2) Параметры узла:

   - IP forwarding

   - Default TTL

   - и так далее

3) Параметры интерфейсов

   - MTU (maximum transfer unit)

   - Broadcast

   - Static routes

4) Параметры TCP:

   - TCP default TTL

   - KeepAlive time

   - И тому подобное

5) Параметры приложений:

   - NIS, NIS+

   - WINS

   - POP3, SMTP, NNTP

6) Параметры аренды:

   - Запрашиваемый IP

   - Срок аренды

   - Идентификатор сервера, который сделал эту аренду

   - и тому подобное

Для управления арендой есть утилита ipconfig

# 37. Управление в сетях. Протокол SNMP.

Модель систем управления компьютерными сетями:

Классическая модель ISP/OSI ( ITU – T X.700 ) рассматривает 5 задач управления:

1) Управление конфигурацией

2) Управление учетом использования ресурсов

3) Управление неисправностями

4) Управление эффективностью

5) Управление защитой

Архитектура систем управления сетями:

1) Management entities: управляющие элементы, управляющие программы, в задачи которых входит управление другими устройствами.

2) Managed devices: управляемые устройства, которые должны в своём составе иметь:

   - Управляющий агент, через которого management entities управляет устройством

   - Управляющая БД, которая проецирует сетевые параметры на стандартные схемы представления параметров в современных протоколах

3) Management proxies: посредники управления, используются когда управляемое устройство очень «глупое» , то есть само не может реализовывать элемент архитектуры, тогда для этого нужен посредник.

   - Управляющий агент

   - Управляющая БД

4) Management environment: среда управления, та компьютерная сеть, по которой происходит передача управляющих команд. В современных компьютерных сетях, это одна и та же среда, что используется для прикладных задач
   - Обычно используется прикладная КС

### Архитектура систем управления сетями

![Архитектура систем управления сетями](img/architecture_configuring_network.png)

Основная задача, которая реализуется – задача управления конфигурацией.

### Управление конфигурацией:

1) Контролирование информации о сетевой и системной конфигурации.

2) Управление программными компонентами

3) Управление аппаратными компонентами

Реализация архитектуры в TCP/IP сделана с помощью протокола SNMP

## SNMP (Simple Network Management Protocol):

Первый стандарт 1988 г. Является основным протоколом управления в TCP/IP.

### Стандарты:

- RFC 1157
- RFC 1441-1450, RFC 1901-1910, RFC2263-2265, RFC 2273-2275, RFC 2573-2575
- RFC 3411 – 3418

### Существует три основных версии протокола: 

1) SNMPv1,

2) SNMPv2 (v2c, v2p,v2u – реализуют разные методы аутентификации) 

3) SNMPv3

Цель: хотим с помощью одного универсального протокола управлять разными устройствами: коммутаторы, маршрутизаторы, серверы, NAT серверы, web серверы, системы защиты информации и так далее. Поэтому необходимо общее представление управляющих команд.

Для этого была придумана общая среда – база управления MIB (management information database). Эта база представляет все задачи управления в виде дерева переменных, которые одинаковы для всех устройств, которые используются. Также SNMP устройства должны представлять информацию в виде этого дерева переменных. То есть SNMP агент на управляемых устройствах должен понимать это дерево переменных, и в таком виде отдавать данные SNMP менеджеру и отвечать в таком виде на запросы SNMP менеджера.

### Концепция переменных:

1) Операция чтения переменных

2) Операция записи переменной

3) Операция чтения следующей переменной (в случае если переменная списочная)

### Переменные:

1) Скалярные

2) Таблицы

## Протокол SNMP:

1) Независим от транспортного протокола, однако обычно используют UDP

2) На уровне представлений используется нотация ASN.1 Basic Encoding Rules, для кодирования сообщений для передачи по сети.

3) Порт управления – 161 (передача команд от менеджера к агенту)

4) Порт уведомлений (snmp trap(ловушки)) – 162 (сообщение менеджеру о чём-то, что произошло в управляемом устройстве)

5) Концепция «ловушек» - при нештатной ситуации менеджер оповещается об этом

### Часть дерева системы MIB

![Часть дерева системы MIB](img/MIB_tree.png)

Используется не только для интернета, а во всех телекоммуникациях.

## Объект SNMP:

1) Текстовое имя

2) Тип объекта

   - Network address

   - IP address

   - Counter (счетчик со сбросом)

   - Gauge (счетчик без сброса)

   - Ticks (для измерения временных параметров

   - Opaque (строки)

3) Определение объекта

4) Доступ к объекту

   - Read-only

   - Write-only (для подачи управляющих команд)

   - Read-write

   - No-access

5) Статус

   - Обязательный (переменная должна быть реализована в любом устройстве) 

   - Необязательный

   - Устаревший

## Безопасность протокола SNMP:

1) Модель безопасности на основе сообществ 

   - Вводится понятие сообщества, нешифруемая строка, которая используется в запросе менеджеру, если строка совпадает, то можем подавать управляющие команды.

   - Используется:
     - SNMPv1
     - SNMPv2c

2) Модель безопасности на основе сторон
   - Вводится понятие стороны:
     - идентификатор стороны
     - логический сетевой адрес
     - протокол аутентификации и связанные параметры
     - протокол шифрования и связанные параметры
   - Используется:
     - SNMPv2p

3) Модель безопасности на основе пользователей

   - Вводится понятие пользователь
     - идентификатор пользователя
     - протокол аутентификации
     - протокол шифрования
     - ключи шифрования
     - ключи аутентификации

   - Используется:
     - SNMPv2u
     - SNMPv3 

# 46. Протокол HTTP. Формат ответа.

[Протокол HTTP - Вопрос 45]()

## Формат ответа.

- `<Status-line>` - Строка статуса 
  - Формат: `<HTTP-VERSION> <Code> <Phrase>`
    - `<HTTP-VERSION>` - Используемая версия Http 
    - `<Code>` - Код ошибки
      - 1xx - информационные
      - 2хх - ОК
      - 3хх - переадресация
      - 4хх - ошибка клиента
      - 5хх - ошибка сервера
    - `<Phrase>` - Кодовая фраза
- `<General-Header>` - Общий заголовок 
- `<Response-header>` - Заголовок ответа 
  - `Location` - переадресация (если, например, ресурс переехал, указывает новый актуальный адрес)
  - `Server` - спецификация сервера (инфо о сервере, аналог `USER-AGENT`)
  - `WWW-Authenticate: basic realm=’localzone’` - сопровождает ошибку о том, что требуется аутентификация (указывает режим аутентификации и область, в которую нужно войти)
- `<Entity-header>` - Заголовок сообщения 
- `<Body>` - тело 

# 47. Архитектура IPv6. Адресация.

**Длина адреса** - 128 разрядов

## Общий формат адреса

![ipv6_format](img/ipv6_format.png)

## **Типы адресов:**

- Unicast:
  - Global - Глобальный адрес
  - Link-local - Адрес линии (без деления на подсети)
  - Site-local - Адрес узла(с делением на подсети)
- Anycast
- Multicast

## Префикс:

![ipv6_prefix](img/ipv6_prefix.png)

 ![provider_id_adress](img/provider_id_adress.png)

## Специальные адреса:

- Петля обратной связи: 0:0:0:0:0:0:0:1
- Не специфицированный адрес: 0:0:0:0:0:0:0:0
- Локальные адреса для линии 1111111010 000..000 iii.iii
  - Используются для адресации в локальных сегментах сетей (соединениях «точка-точка» и т.п.) **Должны НЕ маршрутизироваться!**
- Локальные адреса для сети 1111111011 000..000 sss..sss iii.iii
  - Используются для организации адресации во внутренних сетях При включении в сеть Интернет префикс может быть заменен на «Адрес идент. провайдера». **НЕ должны маршрутизироваться вне данной сети!** 

## Anycast адресация:

![anycast_adressation](img/anycast_adressation.png)

## Групповая адресация:

![group_adressation](img/group_adressation1.png)

![group_adressation](img/group_adressation2.png)

# 48. Архитектура IPv6. Сетевой уровень.

![ipv6_header](img/ipv6_header.png)

В стандартном заголовке нет опций , но у нас есть цепочки заголовков. Цепочки заголовков - это технология придуманная для того чтобы упростить основной заголовок и все ненужные данные разнести в разные заголовки.

## Виды заголовков:

- Hop-by-hop options header - заголовок опций которые передаются всем маршрутизаторам.
- Fragmentation header - если требуется фрагментация.
- Routing header - если требуется маршрутизация от источника.
- Destination options header 
- Authentication header (AH) - заголовок аутентификации
- Encapsulation security payload header (ESP) - заголовок шифрования

## Фрагментация:

![fragmentation](img/fragmentation.png)

## Протокол ARP заменен на NDP.

![arp_ndp](img/arp_ndp.png)

## Протокол ICMPv6:

![ICMPv6_protocol.png](img/ICMPv6_protocol.png)

# 49. Архитектура IPv6. Транспортный уровень, DNS, безопасность.

## Транспортный уровень

*(!TODO)*

[Протокол UDP – 11 вопрос]()

[Протокол TCP – 12-13 вопросы]()

[Протокол SCTP – 14 вопрос]()

Транспортные механизмы в IPv6 не изменились – по-прежнему используются протоколы TCP, UDP, а также с самого начала IPv6 есть поддержка протокола SCTP. RFC 2960, RFC 3257.

## DNS

*(!TODO)*

[DNS – 26-32 вопросы]()

[DNS. Прямой поиск – 27 вопрос ]()

[DNS. Обратный поиск – 31 вопрос]()

- Для прямого преобразования добавлена одна ресурсная запись стандарта DNS, кроме записи `A` появилась запись `AAAA` (`A` - 32 разряда, а теперь 128 разрядов, т.е. 4*`A`, соответственно и длина адреса в 4 раза больше). Описано в RFC 1886.
- Обратное преобразование сделано также, как и в IPv4, через обратную зону, только теперь не через in-addr.arpa, а через ip6.arpa. Описано в RFC 3152.

## Безопасность

- Есть архитектура безопасности IPSEC, которая была разработана еще для IPv4 как внешнее дополнение. В IPv6 эта архитектура уже встроена.
- 2 протокола: Заголовок аутентификации AH и Заголовок шифрования ESP. Они по сути и реализуют эту архитектуру IPSEC, которая позволяет в двух режимах (транпортном и туннельном) обеспечивать полную защиту трафика, поэтому IPv6 изначально хорошо защищенная сеть.

# 50. Архитектура IPv6. Переход от IPv4 к IPv6.

Предпосылки развития связаны с недостатками протокола IPv4:

- Малое адресное пространство (32-битная адресация -> 2<sup>32</sup> = 4294967296 адресов)
- Неудобный формат адреса
- Сложная маршрутизация
- Низкая защищенность
  - Отсутствие шифрования
  - Отсутствие аутентификации
- Низкая эффективность передачи

## Сосуществование стеков

В 1995 году, когда вышел RFC на IPv6, было сказано, что в 2000 году IPv4 не останется, все перейдут на IPv6. Потом сказали, что к 2000 году не удалось, перейдем к 2005, потом к 2010, к 2015, к 2020. Сейчас есть оптимистичный прогноз на 2025 год, но в отличие от всех предыдущих случаев уже сейчас, примерно с 2015 года вся инфраструктура сети Интернет уже готова к переходу на IPv6, все маршрутизаторы поддерживают IPv6, все программные маршрутизаторы поддерживают, все ОС имеют стек протоколов IPv6. И сейчас вопрос перехода не технический, а организационный.

Как происходит сейчас переход на IPv6 (а уже существенная часть сети перешла на IPv6)? Есть несколько способов:

- **Двойные стеки протоколов:** компьютере поднимаются оба стека протоколов и часть приложений привязывается к стеку протоколов IPv4, а часть к IPv6)
- **Туннелирование:** вид маршрутизации, когда трафик одного типа запаковывается в трафик другого типа (используется в VPN). Островки сети IPv6 туннелируются сквозь сети IPv4 через программные туннели и для узлов IPv6 это прозрачно, потому что туннели — это прозрачная технология для прикладных программ.

- **Трансляция адресов:** когда пакет из сети IPv6 пришел на границу сети и дальше идут сети IPv4, то происходит трансляция одного адреса в другой.

 

 
